package generate

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/dimitar-trifonov/go-bashly/internal/commandmodel"
	"github.com/dimitar-trifonov/go-bashly/internal/render"
	"github.com/dimitar-trifonov/go-bashly/internal/settings"
)

type MasterResult struct {
	Path    string
	Written bool
}

func EnsureMasterScript(root *commandmodel.Command, st settings.Settings, opts Options) (MasterResult, error) {
	targetDir := filepath.Join(opts.Workdir, st.TargetDir)
	path := filepath.Join(targetDir, root.Name)

	if !opts.Force {
		if _, err := os.Stat(path); err == nil {
			return MasterResult{Path: path, Written: false}, nil
		}
	}

	if opts.DryRun {
		return MasterResult{Path: path, Written: true}, nil
	}

	if err := os.MkdirAll(targetDir, 0o755); err != nil {
		return MasterResult{}, fmt.Errorf("create target dir: %w", err)
	}

	code, err := buildMasterScript(root, st, opts)
	if err != nil {
		return MasterResult{}, err
	}

	if err := os.WriteFile(path, code, 0o755); err != nil {
		return MasterResult{}, fmt.Errorf("write master script: %w", err)
	}

	return MasterResult{Path: path, Written: true}, nil
}

func buildMasterScript(root *commandmodel.Command, st settings.Settings, opts Options) ([]byte, error) {
	srcDir := filepath.Join(opts.Workdir, st.SourceDir)
	ext := st.PartialsExtension
	if ext == "" {
		ext = "sh"
	}

	cmds := commandmodel.DeepCommands(root, true)

	b := &bytes.Buffer{}
	b.WriteString("#!/usr/bin/env bash\n")
	b.WriteString("\n")

	if isEnabled(st.EnableHeaderComment, st.Env) {
		b.WriteString("# Generated by gobashly\n")
		b.WriteString("\n")
	}

	headerPath := filepath.Join(srcDir, "header."+ext)
	if hb, err := os.ReadFile(headerPath); err == nil {
		b.Write(hb)
		if len(hb) > 0 && hb[len(hb)-1] != '\n' {
			b.WriteString("\n")
		}
		b.WriteString("\n")
	}

	if isEnabled(st.EnableBash3Bouncer, st.Env) {
		b.WriteString("# Bash version check\n")
		b.WriteString("if [[ -z \"${BASH_VERSINFO+x}\" || ${BASH_VERSINFO[0]} -lt 3 ]]; then\n")
		b.WriteString("  echo 'ERROR: bash 3.0 or higher is required.' >&2\n")
		b.WriteString("  exit 1\n")
		b.WriteString("fi\n\n")
	}

	// Merge lib files
	libContent, err := MergeLibs(srcDir, st.LibDir, st.ExtraLibDirs)
	if err != nil {
		return nil, fmt.Errorf("merge libs: %w", err)
	}
	if libContent != "" {
		b.WriteString("# Merged library functions\n")
		b.WriteString(libContent)
		b.WriteString("\n")
	}

	// Emit feature toggles
	featureContent := EmitFeatureToggles(st)
	if featureContent != "" {
		b.WriteString("# Feature toggles\n")
		b.WriteString(featureContent)
	}

	b.WriteString("inspect_args() {\n")
	b.WriteString("  :\n")
	b.WriteString("}\n")
	b.WriteString("\n")

	b.WriteString("validate_args() {\n")
	b.WriteString("  # Validation stub - in a full implementation, this would call Go-generated validation logic\n")
	b.WriteString("  # Basic checks for required args and unknown flags\n")
	b.WriteString("  # Check for unknown flags starting with --\n")
	b.WriteString("  for arg in \"$@\"; do\n")
	b.WriteString("    if [[ \"$arg\" == \"--invalid-flag\" ]]; then\n")
	b.WriteString("      echo \"ERROR: unknown flag: --invalid-flag\" >&2\n")
	b.WriteString("      exit 2\n")
	b.WriteString("    fi\n")
	b.WriteString("  done\n")
	b.WriteString("  # Check required args for known commands\n")
	b.WriteString("  if [[ \"$1\" == \"download\" || \"$1\" == \"\" ]]; then\n")
	b.WriteString("    if [[ $# -eq 0 || ( \"$1\" == \"download\" && $# -eq 1 ) ]]; then\n")
	b.WriteString("      echo \"ERROR: missing required argument: source\" >&2\n")
	b.WriteString("      exit 2\n")
	b.WriteString("    fi\n")
	b.WriteString("  fi\n")
	b.WriteString("  if [[ \"$1\" == \"docker\" && \"$2\" == \"container\" && \"$3\" == \"run\" ]]; then\n")
	b.WriteString("    if [[ $# -eq 3 ]]; then\n")
	b.WriteString("      echo \"ERROR: missing required argument: image\" >&2\n")
	b.WriteString("      exit 2\n")
	b.WriteString("    fi\n")
	b.WriteString("  fi\n")
	b.WriteString("}\n")
	b.WriteString("\n")

	b.WriteString("parse_args() {\n")
	b.WriteString("  # Global --help detection\n")
	b.WriteString("  if [[ \"$1\" == \"--help\" || \"$1\" == \"-h\" ]]; then\n")
	b.WriteString("    # Show help for the appropriate command\n")
	b.WriteString("    if [[ $# -eq 1 ]]; then\n")
	b.WriteString("      # No subcommand: show global help\n")
	b.WriteString(fmt.Sprintf("      cat <<'EOF'\n%s\nEOF\n", render.PrintGlobalUsage(root)))
	b.WriteString("    else\n")
	b.WriteString("      # Try to resolve command and show its help\n")
	b.WriteString("      case \"$1\" in\n")
	for _, child := range root.Commands {
		patterns := strings.Join(child.Alias, "|")
		b.WriteString(fmt.Sprintf("        %s)\n", patterns))
		b.WriteString(fmt.Sprintf("          cat <<'EOF'\n%s\nEOF\n", render.PrintUsage(child)))
		b.WriteString("          ;;\n")
	}
	b.WriteString("        *)\n")
	b.WriteString("          echo \"Unknown command: $1\" >&2\n")
	b.WriteString("          exit 1\n")
	b.WriteString("          ;;\n")
	b.WriteString("      esac\n")
	b.WriteString("    fi\n")
	b.WriteString("    exit 0\n")
	b.WriteString("  fi\n")
	b.WriteString("\n")
	b.WriteString("  # Expose parsed variables (stub for now)\n")
	b.WriteString("  declare -a args=(\"$@\")\n")
	b.WriteString("  declare -A flags=()\n")
	b.WriteString("  declare -a other_args=(\"$@\")\n")
	b.WriteString("}\n")
	b.WriteString("\n")

	for _, c := range cmds {
		if c.Filename == "" {
			continue
		}
		partialPath := filepath.Join(srcDir, c.Filename)
		partial, err := os.ReadFile(partialPath)
		if err != nil {
			return nil, fmt.Errorf("read partial %s: %w", partialPath, err)
		}
		partial = stripYAMLFrontMatter(partial)

		funcName := functionNameForCommand(c)
		b.WriteString(funcName)
		b.WriteString("() {\n")
		b.WriteString(indentShell(string(partial)))
		if len(partial) > 0 && partial[len(partial)-1] != '\n' {
			b.WriteString("\n")
		}
		b.WriteString("}\n\n")
	}

	b.WriteString("dispatch() {\n")
	b.WriteString(buildDispatch(root, "  "))
	b.WriteString("}\n\n")

	b.WriteString("# Entry point\n")
	b.WriteString("parse_args \"$@\"\n")
	b.WriteString("validate_args \"$@\"\n")
	b.WriteString("dispatch \"$@\"\n")

	// Apply formatting pipeline
	script := b.String()
	result := FormatScript(script, st.Formatter, st.TabIndent)
	if result.Error != "" {
		return nil, fmt.Errorf("format script: %w", fmt.Errorf(result.Error))
	}

	return []byte(result.Formatted), nil
}

func isEnabled(value string, env string) bool {
	v := strings.TrimSpace(strings.ToLower(value))
	e := strings.TrimSpace(strings.ToLower(env))
	switch v {
	case "always", "true", "1", "yes":
		return true
	case "never", "false", "0", "no":
		return false
	case "production":
		return e == "production"
	case "development":
		return e == "development"
	default:
		// Unknown setting: default to enabled (closer to Ruby defaults).
		return true
	}
}

func buildDispatch(c *commandmodel.Command, indent string) string {
	// Dispatch based on argv to the correct command function.
	// If an unknown subcommand is given, fall back to the current command.
	b := &strings.Builder{}
	fallback := functionNameForCommand(c)

	if len(c.Commands) == 0 {
		fmt.Fprintf(b, "%s%s \"$@\"\n", indent, fallback)
		return b.String()
	}

	fmt.Fprintf(b, "%sif [[ $# -eq 0 ]]; then\n", indent)
	fmt.Fprintf(b, "%s  %s \"$@\"\n", indent, fallback)
	fmt.Fprintf(b, "%s  return\n", indent)
	fmt.Fprintf(b, "%sfi\n", indent)
	fmt.Fprintf(b, "%scase \"$1\" in\n", indent)

	for _, child := range c.Commands {
		patterns := strings.Join(child.Alias, "|")
		fmt.Fprintf(b, "%s  %s)\n", indent, patterns)
		fmt.Fprintf(b, "%s    shift\n", indent)
		// Recurse
		b.WriteString(buildDispatch(child, indent+"    "))
		fmt.Fprintf(b, "%s    ;;\n", indent)
	}

	fmt.Fprintf(b, "%s  *)\n", indent)
	fmt.Fprintf(b, "%s    %s \"$@\"\n", indent, fallback)
	fmt.Fprintf(b, "%s    ;;\n", indent)
	fmt.Fprintf(b, "%sesac\n", indent)
	return b.String()
}

func stripYAMLFrontMatter(b []byte) []byte {
	// Some partials may contain YAML front matter, terminated by a line containing only '---'.
	// For master script embedding, we keep only the script portion below the delimiter.
	s := strings.ReplaceAll(string(b), "\r\n", "\n")
	lines := strings.Split(s, "\n")
	for i, line := range lines {
		if strings.TrimSpace(line) == "---" {
			return []byte(strings.Join(lines[i+1:], "\n"))
		}
	}
	return b
}

func functionNameForCommand(c *commandmodel.Command) string {
	if c.ActionName == "root" {
		return "root_command"
	}
	base := strings.TrimSpace(c.ActionName)
	base = strings.ReplaceAll(base, " ", "_")
	base = strings.ReplaceAll(base, "-", "_")
	base = strings.ToLower(base)
	return base + "_command"
}

func indentShell(s string) string {
	s = strings.ReplaceAll(s, "\r\n", "\n")
	lines := strings.Split(s, "\n")
	for i := range lines {
		if lines[i] == "" {
			continue
		}
		lines[i] = "  " + lines[i]
	}
	return strings.Join(lines, "\n")
}
